---  
layout: post  
title: "python基础教程"  
categories: python  
tags: python  
---  
* content  
{:toc}  





# 基础语法  

## python 保留字  

保留字即关键字，我们不能把它们用作任何标识符名称。Python的标准库提供了一个keyword module，可以输出当前版本的所有关键字：  

```python  
>>> import keyword  
>>> keyword.kwlist  
['and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'exec', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'not', 'or', 'pass', 'print', 'raise', 'return', 'try', 'while', 'with', 'yield']  
```  

## 注释  

Python中单行注释以#开头，多行注释用三个单引号（'''）或者三个双引号（"""）将注释括起来。  

## 行与缩进  

python最具特色的就是使用缩进来表示代码块。缩进的空格数是可变的，但是同一个代码块的语句必须包含相同的缩进空格数。  

## 字符串  

- python中单引号和双引号使用完全相同。  
- 使用三引号('''或""")可以指定一个多行字符串。  
- 转义符 \  
- 自然字符串， 通过在字符串前加r或R。 如 r"this is a line with \n" 则\n会显示，并不是换行。  
- python允许处理unicode字符串，加前缀u或U， 如 u"this is an unicode string"。  
- 字符串是不可变的。  
- 按字面意义级联字符串，如"this " "is " "string"会被自动转换为this is string。  

#  基本数据类型  

## Numbers（数字）  

Python 3支持int、float、bool、complex（复数）。  

数值类型的赋值和计算都是很直观的，就像大多数语言一样。内置的type()函数可以用来查询变量所指的对象类型。  

```python  
>>> a, b, c, d = 20, 5.5, True, 4+3j  
>>> print(type(a), type(b), type(c), type(d))  
```  

数值运算：  

```  
>>> 5 + 4  # 加法  
9  
>>> 4.3 - 2 # 减法  
2.3  
>>> 3 * 7  # 乘法  
21  
>>> 2 / 4  # 除法，得到一个浮点数  
0.5  
>>> 2 // 4 # 除法，得到一个整数  
0  
>>> 17 % 3 # 取余  
2  
>>> 2 ** 5 # 乘方  
32  
```  

**注意：**  

- 1、Python可以同时为多个变量赋值，如a, b = 1, 2。  
- 2、一个变量可以通过赋值指向不同类型的对象。  
- 3、数值的除法（/）总是返回一个浮点数，要获取整数使用//操作符。  
- 4、在混合计算时，Pyhton会把整型转换成为浮点数。  

## String（字符串）  

Python中的字符串str用单引号(' ')或双引号(" ")括起来，同时使用反斜杠(\)转义特殊字符。  

```python  
>>> s = 'Yes,he doesn\'t'  
>>> print(s, type(s), len(s))  
Yes,he doesn't  14  
```  

如果你不想让反斜杠发生转义，可以在字符串前面添加一个r，表示原始字符串：  

```python  
>>> print('\root')  
oot  
>>> print(r'\root')  
\root  
```  

另外，反斜杠可以作为续行符，表示下一行是上一行的延续。还可以使用"""..."""或者'''...'''跨越多行。  

字符串可以使用 + 运算符串连接在一起，或者用 * 运算符重复：  

```  
>>> print('str'+'ing', 'my'*3)  
string mymymy  
```  

Python中的字符串有两种索引方式，第一种是从左往右，从0开始依次增加；第二种是从右往左，从-1开始依次减少。  

注意，没有单独的字符类型，一个字符就是长度为1的字符串。  

```  
>>> word = 'Python'  
>>> print(word[0], word[5])  
P n  
>>> print(word[-1], word[-6])  
n P  
```  

还可以对字符串进行切片，获取一段子串。用冒号分隔两个索引，形式为变量[头下标:尾下标]。  

截取的范围是前闭后开的，并且两个索引都可以省略：  

```  
>>> word = 'ilovepython'  
>>> word[1:5]  
'love'  
>>> word[:]  
'ilovepython'  
>>> word[5:]  
'python'  
>>> word[-10:-6]  
'love'  
```  

与C字符串不同的是，Python字符串不能被改变。向一个索引位置赋值，比如word[0] = 'm'会导致错误。  

**注意：**  

- 1、反斜杠可以用来转义，使用r可以让反斜杠不发生转义。  
- 2、字符串可以用+运算符连接在一起，用*运算符重复。  
- 3、Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。  
- 4、Python中的字符串不能改变。  

## List（列表）  

List（列表） 是 Python 中使用最频繁的数据类型。  

列表是写在方括号之间、用逗号分隔开的元素列表。列表中元素的类型可以不相同：  

```  
>>> a = ['him', 25, 100, 'her']  
>>> print(a)  
['him', 25, 100, 'her']  
```  

和字符串一样，列表同样可以被索引和切片，列表被切片后返回一个包含所需元素的新列表。详细的在这里就不赘述了。  

列表还支持串联操作，使用+操作符：  

```  
>>> a = [1, 2, 3, 4, 5]  
>>> a + [6, 7, 8]  
[1, 2, 3, 4, 5, 6, 7, 8]  
```  

与Python字符串不一样的是，列表中的元素是可以改变的：  

```  
>>> a = [1, 2, 3, 4, 5, 6]  
>>> a[0] = 9  
>>> a[2:5] = [13, 14, 15]  
>>> a  
[9, 2, 13, 14, 15, 6]  
>>> a[2:5] = []   # 删除  
>>> a  
[9, 2, 6]  
```  

List内置了有很多方法，例如append()、pop()等等，这在后面会讲到。  

**注意：**  

- 1、List写在方括号之间，元素用逗号隔开。  
- 2、和字符串一样，list可以被索引和切片。  
- 3、List可以使用+操作符进行拼接。  
- 4、List中的元素是可以改变的。  

## Tuple（元组）  

元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。  

元组中的元素类型也可以不相同：  

```  
>>> a = (1991, 2014, 'physics', 'math')  
>>> print(a, type(a), len(a))  
(1991, 2014, 'physics', 'math') <class 'tuple'> 4  
```  

元组与字符串类似，可以被索引且下标索引从0开始，也可以进行截取/切片（看上面，这里不再赘述）。  

其实，可以把字符串看作一种特殊的元组。  

```  
>>> tup = (1, 2, 3, 4, 5, 6)  
>>> print(tup[0], tup[1:5])  
1 (2, 3, 4, 5)  
>>> tup[0] = 11  # 修改元组元素的操作是非法的  
```  

虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。  

构造包含0个或1个元素的tuple是个特殊的问题，所以有一些额外的语法规则：  

```  
tup1 = () # 空元组  
tup2 = (20,) # 一个元素，需要在元素后添加逗号  
```  

另外，元组也支持用+操作符：  

```  
>>> tup1, tup2 = (1, 2, 3), (4, 5, 6)  
>>> print(tup1+tup2)  
(1, 2, 3, 4, 5, 6)  
```  

string、list和tuple都属于sequence（序列）。  

**注意：**  

- 1、与字符串一样，元组的元素不能修改。  
- 2、元组也可以被索引和切片，方法一样。  
- 3、注意构造包含0或1个元素的元组的特殊语法规则。  
- 4、元组也可以使用+操作符进行拼接。  

## Sets（集合）  

集合（set）是一个无序不重复元素的集。  

基本功能是进行成员关系测试和消除重复元素。  

可以使用大括号 或者 set()函数创建set集合，注意：创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。  

```  
>>> student = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'}  
>>> print(student)   # 重复的元素被自动去掉  
{'Jim', 'Jack', 'Mary', 'Tom', 'Rose'}  
>>> 'Rose' in student  # membership testing（成员测试）  
True  
>>> # set可以进行集合运算  
...  
>>> a = set('abracadabra')  
>>> b = set('alacazam')  
>>> a  
{'a', 'b', 'c', 'd', 'r'}  
>>> a - b     # a和b的差集  
{'b', 'd', 'r'}  
>>> a | b     # a和b的并集  
{'l', 'm', 'a', 'b', 'c', 'd', 'z', 'r'}  
>>> a & b     # a和b的交集  
{'a', 'c'}  
>>> a ^ b     # a和b中不同时存在的元素  
{'l', 'm', 'b', 'd', 'z', 'r'}  
```  

## Dictionaries（字典）  

字典（dictionary）是Python中另一个非常有用的内置数据类型。  

字典是一种映射类型（mapping type），它是一个无序的键 : 值对集合。  

关键字必须使用不可变类型，也就是说list和包含可变类型的tuple不能做关键字。  

在同一个字典中，关键字还必须互不相同。  

```  
>>> dic = {}  # 创建空字典  
>>> tel = {'Jack':1557, 'Tom':1320, 'Rose':1886}  
>>> tel  
{'Tom': 1320, 'Jack': 1557, 'Rose': 1886}  
>>> tel['Jack']   # 主要的操作：通过key查询  
1557  
>>> del tel['Rose']  # 删除一个键值对  
>>> tel['Mary'] = 4127  # 添加一个键值对  
>>> tel  
{'Tom': 1320, 'Jack': 1557, 'Mary': 4127}  
>>> list(tel.keys())  # 返回所有key组成的list  
['Tom', 'Jack', 'Mary']  
>>> sorted(tel.keys()) # 按key排序  
['Jack', 'Mary', 'Tom']  
>>> 'Tom' in tel       # 成员测试  
True  
>>> 'Mary' not in tel  # 成员测试  
False  
```  

构造函数 dict() 直接从键值对sequence中构建字典，当然也可以进行推导，如下：  

```  
>>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])  
{'jack': 4098, 'sape': 4139, 'guido': 4127}  

>>> {x: x**2 for x in (2, 4, 6)}  
{2: 4, 4: 16, 6: 36}  

>>> dict(sape=4139, guido=4127, jack=4098)  
{'jack': 4098, 'sape': 4139, 'guido': 4127}  
```  

另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。  

**注意：**  

- 1、字典是一种映射类型，它的元素是键值对。  
- 2、字典的关键字必须为不可变类型，且不能重复。  
- 3、创建空字典使用{ }。  

# 运算符  

## 算数运算符  

以下假设变量a为10，变量b为21：  

| 运算符 | 描述                  | 实例                                    |  
| ------ | --------------------- | --------------------------------------- |  
| +      |                       |                                         |  
| -      |                       |                                         |  
| *      |                       |                                         |  
| /      | 除 - x 除以 y         | b / a 输出结果 2.1                      |  
| %      | 取模\- 返回除法的余数 | b % a 输出结果 1                        |  
| **     | 幂                    | a**b 为10的21次方                       |  
| //     |                       | 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 |  

## Python比较运算符  

以下假设变量a为10，变量b为20：  

| 运算符 | 描述                                                         | 实例                  |  
| :----- | :----------------------------------------------------------- | :-------------------- |  
| ==     | 等于 - 比较对象是否相等                                      | (a == b) 返回 False。 |  
| !=     | 不等于 - 比较两个对象是否不相等                              | (a != b) 返回 True.   |  
| >      | 大于 - 返回x是否大于y                                        | (a > b) 返回 False。  |  
| <      | 小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。<br />这分别与特殊的变量True和False等价。注意，这些变量名的大写。 | (a < b) 返回 True。   |  
| >=     | 大于等于 - 返回x是否大于等于y。                              | (a >= b) 返回 False。 |  
| <=     | 小于等于 - 返回x是否小于等于y。                              | (a <= b) 返回 True。  |  

## Python位运算符  

按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：  

下表中变量 a 为 60，b 为 13。  

| 运算符 | 描述                                                         | 实例                                                         |  
| :----- | :----------------------------------------------------------- | :----------------------------------------------------------- |  
| &      | 按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 | (a & b) 输出结果 12 ，二进制解释： 0000 1100                 |  
| \|     | 按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。 | (a \| b) 输出结果 61 ，二进制解释： 0011 1101                |  
| ^      | 按位异或运算符：当两对应的二进位相异时，结果为1              | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001                 |  
| ~      | 按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 | (~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。 |  
| <<     | 左移动运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000                 |  
| >>     | 右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数 | a >> 2 输出结果 15 ，二进制解释： 0000 1111                  |  

## Python逻辑运算符  

Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:  

| 运算符 | 逻辑表达式 | 描述                                                         | 实例                    |  
| :----- | :--------- | :----------------------------------------------------------- | :---------------------- |  
| and    | x and y    | 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。 | (a and b) 返回 20。     |  
| or     | x or y     | 布尔"或" - 如果 x 是 True，它返回 x的值，否则它返回 y 的计算值。 | (a or b) 返回 10。      |  
| not    | not x      | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False |  

## Python成员运算符  

除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。  

| 运算符 | 描述                                                    | 实例                                              |  
| :----- | :------------------------------------------------------ | :------------------------------------------------ |  
| in     | 如果在指定的序列中找到值返回 True，否则返回 False。     | x 在 y 序列中 , 如果 x 在 y 序列中返回 True。     |  
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False。 | x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 |  

以下实例演示了Python所有成员运算符的操作：  

```python  
#!/usr/bin/python3  
#coding=utf-8  
a = 10  
b = 20  
list = [1, 2, 3, 4, 5 ];  

if ( a in list ):  
   print ("1 - 变量 a 在给定的列表中 list 中")  
else:  
   print ("1 - 变量 a 不在给定的列表中 list 中")  

if ( b not in list ):  
   print ("2 - 变量 b 不在给定的列表中 list 中")  
else:  
   print ("2 - 变量 b 在给定的列表中 list 中")  

# 修改变量 a 的值  
a = 2  
if ( a in list ):  
   print ("3 - 变量 a 在给定的列表中 list 中")  
else:  
   print ("3 - 变量 a 不在给定的列表中 list 中")  
```  

以上实例输出结果：  

```python  
1 - 变量 a 不在给定的列表中 list 中  
2 - 变量 b 不在给定的列表中 list 中  
3 - 变量 a 在给定的列表中 list 中  
```  

## Python身份运算符  

身份运算符用于比较两个对象的存储单元  

| 运算符 | 描述                                       | 实例                                                       |  
| :----- | :----------------------------------------- | :--------------------------------------------------------- |  
| is     | is是判断两个标识符是不是引用自一个对象     | x is y, 如果 id(x) 等于 id(y) , **is** 返回结果 1          |  
| is not | is not是判断两个标识符是不是引用自不同对象 | x is not y, 如果 id(x) 不等于 id(y). **is not** 返回结果 1 |  

以下实例演示了Python所有身份运算符的操作：  

```  
#!/usr/bin/python3  
#coding=utf-8  

a = 20  
b = 20  

if ( a is b ):  
   print ("1 - a 和 b 有相同的标识")  
else:  
   print ("1 - a 和 b 没有相同的标识")  

if ( id(a) == id(b) ):  
   print ("2 - a 和 b 有相同的标识")  
else:  
   print ("2 - a 和 b 没有相同的标识")  

# 修改变量 b 的值  
b = 30  
if ( a is b ):  
   print ("3 - a 和 b 有相同的标识")  
else:  
   print ("3 - a 和 b 没有相同的标识")  

if ( a is not b ):  
   print ("4 - a 和 b 没有相同的标识")  
else:  
   print ("4 - a 和 b 有相同的标识")  
```  

以上实例输出结果：  

```  
1 - a 和 b 有相同的标识  
2 - a 和 b 有相同的标识  
3 - a 和 b 没有相同的标识  
4 - a 和 b 没有相同的标识  
```  

------  

## Python运算符优先级  

以下表格列出了从最高到最低优先级的所有运算符：  

| 运算符                   | 描述                                                   |  
| :----------------------- | :----------------------------------------------------- |  
| **                       | 指数 (最高优先级)                                      |  
| ~ + -                    | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |  
| * / % //                 | 乘，除，取模和取整除                                   |  
| + -                      | 加法减法                                               |  
| >> <<                    | 右移，左移运算符                                       |  
| &                        | 位 'AND'                                               |  
| ^ \|                     | 位运算符                                               |  
| <= < > >=                | 比较运算符                                             |  
| <> == !=                 | 等于运算符                                             |  
| = %= /= //= -= += *= **= | 赋值运算符                                             |  
| is is not                | 身份运算符                                             |  
| in not in                | 成员运算符                                             |  
| not or and               | 逻辑运算符                                             |  

以下实例演示了Python所有运算符优先级的操作：  

```  
#!/usr/bin/python3  
#coding=utf-8  
a = 20  
b = 10  
c = 15  
d = 5  
e = 0  

e = (a + b) * c / d       #( 30 * 15 ) / 5  
print ("(a + b) * c / d 运算结果为：",  e)  

e = ((a + b) * c) / d     # (30 * 15 ) / 5  
print ("((a + b) * c) / d 运算结果为：",  e)  

e = (a + b) * (c / d);    # (30) * (15/5)  
print ("(a + b) * (c / d) 运算结果为：",  e)  

e = a + (b * c) / d;      #  20 + (150/5)  
print ("a + (b * c) / d 运算结果为：",  e)  
```  

以上实例输出结果：  

```  
(a + b) * c / d 运算结果为： 90.0  
((a + b) * c) / d 运算结果为： 90.0  
(a + b) * (c / d) 运算结果为： 90.0  
a + (b * c) / d 运算结果为： 50.0  
```  

## python字符串  

# 字符串  

除了数字，Python也能操作字符串。字符串有几种表达方式，可以使用单引号或双引号括起来：  

```  
>>> 'spam eggs'  
'spam eggs'  
>>> 'doesn\'t'  
"doesn't"  
>>> "doesn't"  
"doesn't"  
>>> '"Yes," he said.'  
'"Yes," he said.'  
>>> "\"Yes,\" he said."  
'"Yes," he said.'  
>>> '"Isn\'t," she said.'  
'"Isn\'t," she said.'  
```  

Python中使用反斜杠转义引号和其它特殊字符来准确地表示。  

如果字符串包含有单引号但不含双引号，则字符串会用双引号括起来，否则用单引号括起来。对于这样的输入字符串，print() 函数会产生更易读的输出。  

跨行的字面字符串可用以下几种方法表示。使用续行符，即在每行最后一个字符后使用反斜线来说明下一行是上一行逻辑上的延续：  

以下使用 \n 来添加新行：  

```  
>>> '"Isn\'t," she said.'  
'"Isn\'t," she said.'  
>>> print('"Isn\'t," she said.')  
"Isn't," she said.  
>>> s = 'First line.\nSecond line.'  # \n 意味着新行  
>>> s  # 不使用 print(), \n 包含在输出中  
'First line.\nSecond line.'  
>>> print(s)  # 使用 print(), \n 输出一个新行  
First line.  
Second line.  
```  

以下使用 反斜线（\） 来续行：  

```  
hello = "This is a rather long string containing\n\  
several lines of text just as you would do in C.\n\  
    Note that whitespace at the beginning of the line is\  
 significant."  

print(hello)  
```  

注意，其中的换行符仍然要使用 \n 表示——反斜杠后的换行符被丢弃了。以上例子将如下输出：  

```  
This is a rather long string containing  
several lines of text just as you would do in C.  
    Note that whitespace at the beginning of the line is significant.  
```  

或者，字符串可以被 """ （三个双引号）或者 ''' （三个单引号）括起来。使用三引号时，换行符不需要转义，它们会包含在字符串中。以下的例子使用了一个转义符，避免在最开始产生一个不需要的空行。  

```  
print("""\  
Usage: thingy [OPTIONS]  
     -h                        Display this usage message  
     -H hostname               Hostname to connect to  
""")  
```  

其输出如下：  

```  
Usage: thingy [OPTIONS]  
     -h                        Display this usage message  
     -H hostname               Hostname to connect to  
```  

如果我们使用"原始"字符串，那么 \n 不会被转换成换行，行末的的反斜杠，以及源码中的换行符，都将作为数据包含在字符串内。例如：  

```  
hello = r"This is a rather long string containing\n\  
several lines of text much as you would do in C."  

print(hello)  
```  

将会输出：  

```  
This is a rather long string containing\n\  
several lines of text much as you would do in C.  
```  

字符串可以使用 + 运算符串连接在一起，或者用 * 运算符重复：  

```  
>>> word = 'Help' + 'A'  
>>> word  
'HelpA'  
>>> '<' + word*5 + '>'  
''  
```  

两个紧邻的字面字符串将自动被串连；上例的第一行也可以写成 word = 'Help' 'A' ；这样的操作只在两个字面值间有效，不能随意用于字符串表达式中：  

```  
>>> 'str' 'ing'                   #  <- string="">>> 'str'.strip() + 'ing'   #  <- string="">>> 'str'.strip() 'ing'     #  <-  这样操作错误   File "", line 1, in ?  
    'str'.strip() 'ing'  
                      ^  
SyntaxError: invalid syntax  
```  

字符串可以被索引；就像 C 语言一样，字符串的第一个字符的索引为 0。没有单独的字符类型；一个字符就是长度为一的字符串。就像Icon编程语言一样，子字符串可以使用分切符来指定：用冒号分隔的两个索引。  

```  
>>> word[4]  
'A'  
>>> word[0:2]  
'Hl'  
>>> word[2:4]  
'ep'  
```  

默认的分切索引很有用：默认的第一个索引为零，第二个索引默认为字符串可以被分切的长度。  

```  
>>> word[:2]    # 前两个字符  
'He'  
>>> word[2:]    # 除了前两个字符之外，其后的所有字符  
'lpA'  
```  

不同于C字符串的是，Python字符串不能被改变。向一个索引位置赋值会导致错误：  

```  
>>> word[0] = 'x'  
Traceback (most recent call last):  
  File "", line 1, in ?  
TypeError: 'str' object does not support item assignment  
>>> word[:1] = 'Splat'  
Traceback (most recent call last):  
  File "", line 1, in ?  
TypeError: 'str' object does not support slice assignment  
```  

然而，用组合内容的方法来创建新的字符串是简单高效的：  

```  
>>> 'x' + word[1:]  
'xelpA'  
>>> 'Splat' + word[4]  
'SplatA'  
在分切操作字符串时，有一个很有用的规律： s[:i] + s[i:] 等于 s.  

>>> word[:2] + word[2:]  
'HelpA'  
>>> word[:3] + word[3:]  
'HelpA'  
```  

对于有偏差的分切索引的处理方式也很优雅：一个过大的索引将被字符串的大小取代，上限值小于下限值将返回一个空字符串。  

```  
>>> word[1:100]  
'elpA'  
>>> word[10:]  

>>> word[2:1]  
```  

在索引中可以使用负数，这将会从右往左计数。例如：  

```  
>>> word[-1]     # 最后一个字符  
'A'  
>>> word[-2]     # 倒数第二个字符  
'p'  
>>> word[-2:]    # 最后两个字符  
'pA'  
>>> word[:-2]    # 除了最后两个字符之外，其前面的所有字符  
'Hel'  
但要注意， -0 和 0 完全一样，所以 -0 不会从右开始计数！  

>>> word[-0]     # (既然 -0 等于 0)  
'H'  
```  

超出范围的负数索引会被截去多余部分，但不要尝试在一个单元素索引（非分切索引）里使用：  

```  
>>> word[-100:]  
'HelpA'  
>>> word[-10]    # 错误  
Traceback (most recent call last):  
  File "", line 1, in ?  
IndexError: string index out of range  
```  

有一个方法可以让您记住分切索引的工作方式，想像索引是指向字符之间，第一个字符左边的数字是 0。接着，有n个字符的字符串最后一个字符的右边是索引n，例如：  

```  
 +---+---+---+---+---+  
 | H | e | l | p | A |  
 +---+---+---+---+---+  
 0   1   2   3   4   5  
-5  -4  -3  -2  -1  
```  

第一行的数字 0...5 给出了字符串中索引的位置；第二行给出了相应的负数索引。分切部分从 i 到 j 分别由在边缘被标记为 i 和 j 的全部字符组成。  

对于非负数分切部分，如果索引都在有效范围内，分切部分的长度就是索引的差值。例如， word[1:3] 的长度是2。  

内置的函数 len() 用于返回一个字符串的长度：  

```python  
>>> s = 'supercalifragilisticexpialidocious'  
>>> len(s)  
34  
```  

# 列表  

Python囊括了大量的复合数据类型，用于组织其它数值。最有用的是列表，即写在方括号之间、用逗号分隔开的数值列表。列表内的项目不必全是相同的类型。  

```  
>>> a = ['spam', 'eggs', 100, 1234]  
a  
['spam', 'eggs', 100, 1234]  
squares = [1, 4, 9, 16, 25]  
squares  
[1, 4, 9, 16, 25]  
```  

像字符串一样，列表可以被索引和切片：  

```python  
squares[0]  # 索引返回的指定项  
1  
squares[-1]  
25  
squares[-3:]  # 切割列表并返回新的列表  
[9, 16, 25]  
 
所有的分切操作返回一个包含有所需元素的新列表。如下例中，分切将返回列表 squares 的一个拷贝：  

 
>>> squares[:]  
[1, 4, 9, 16, 25]  
 
列表还支持拼接操作：  

 
>>> squares + [36, 49, 64, 81, 100]  
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]  
 
Python 字符串是固定的，列表可以改变其中的元素：  

 
>>> cubes = [1, 8, 27, 65, 125]  
4  3  
64  
cubes[3] = 64  # 修改列表值  
cubes  
[1, 8, 27, 64, 125]  
 
您也可以通过使用append()方法在列表的末尾添加新项：  

 
>>> cubes.append(216)  # cube列表中添加新值  
cubes.append(7  3)  #  cube列表中添加第七个值  
cubes  
[1, 8, 27, 64, 125, 216, 343]  
 
你也可以修改指定区间的列表值：  

 
>>> letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']  
letters  
['a', 'b', 'c', 'd', 'e', 'f', 'g']  

#替换一些值  

letters[2:5] = ['C', 'D', 'E']  
letters  
['a', 'b', 'C', 'D', 'E', 'f', 'g']  


#移除值  
letters[2:5] = []  

letters  
['a', 'b', 'f', 'g']  


#清除列表  

letters[:] = []  
letters  
[]  

 
内置函数 len() 用于统计列表：  

>>> letters = ['a', 'b', 'c', 'd']  
len(letters)  
4  
 
也可以使用嵌套列表（在列表里创建其它列表），例如：  

>>> a = ['a', 'b', 'c']  
n = [1, 2, 3]  
x = [a, n]  
x  
[['a', 'b', 'c'], [1, 2, 3]]  
x[0]  
['a', 'b', 'c']  
x[0][1]  
'b'  
```  

#  元组  

Python 的元组与列表类似，不同之处在于元组的元素不能修改。  

元组使用小括号，列表使用方括号。  

元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。  

如下实例：  

```  
tup1 = ('Google', 'W3CSchool', 1997, 2000);  
tup2 = (1, 2, 3, 4, 5 );  
tup3 = "a", "b", "c", "d";  
```  

创建空元组  

```  
tup1 = ();  
```  

元组中只包含一个元素时，需要在元素后面添加逗号  

```  
tup1 = (50,);  
```  

元组与字符串类似，下标索引从0开始，可以进行截取，组合等。  

------  

## 访问元组  

元组可以使用下标索引来访问元组中的值，如下实例:  

```  
#!/usr/bin/python3  

tup1 = ('Google', 'W3CSchool', 1997, 2000)  
tup2 = (1, 2, 3, 4, 5, 6, 7 )  

print ("tup1[0]: ", tup1[0])  
print ("tup2[1:5]: ", tup2[1:5])  
```  

以上实例输出结果：  

```  
tup1[0]:  Google  
tup2[1:5]:  (2, 3, 4, 5)  
```  

------  

## 修改元组  

元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:  

```  
#!/usr/bin/python3  

tup1 = (12, 34.56);  
tup2 = ('abc', 'xyz')  

# 以下修改元组元素操作是非法的。  
# tup1[0] = 100  

# 创建一个新的元组  
tup3 = tup1 + tup2;  
print (tup3)  
```  

以上实例输出结果：  

```  
(12, 34.56, 'abc', 'xyz')  
```  

------  

## 删除元组  

元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:  

```  
#!/usr/bin/python3  

tup = ('Google', 'W3CSchool', 1997, 2000)  

print (tup)  
del tup;  
print ("删除后的元组 tup : ")  
print (tup)  
```  

以上实例元组被删除后，输出变量会有异常信息，输出如下所示：  

```  
删除后的元组 tup :  
Traceback (most recent call last):  
  File "test.py", line 8, in <module>  
    print (tup)  
NameError: name 'tup' is not defined  
```  

------  

## 元组运算符  

与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。  

| Python 表达式                | 结果                         | 描述         |  
| :--------------------------- | :--------------------------- | :----------- |  
| len((1, 2, 3))               | 3                            | 计算元素个数 |  
| (1, 2, 3) + (4, 5, 6)        | (1, 2, 3, 4, 5, 6)           | 连接         |  
| ['Hi!'] * 4                  | ['Hi!', 'Hi!', 'Hi!', 'Hi!'] | 复制         |  
| 3 in (1, 2, 3)               | True                         | 元素是否存在 |  
| for x in (1, 2, 3): print x, | 1 2 3                        | 迭代         |  

------  

## 元组索引，截取  

因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：  

元组：  

```  
L = ('Google', 'Taobao', 'W3CSchool')  
```  

| Python 表达式 | 结果                     | 描述                                 |  
| :------------ | :----------------------- | :----------------------------------- |  
| L[2]          | 'W3CSchool!'             | 读取第三个元素                       |  
| L[-2]         | 'Taobao'                 | 反向读取；读取倒数第二个元素         |  
| L[1:]         | ('Taobao', 'W3CSchool!') | 截取元素，从第二个开始后的所有元素。 |  

运行实例如下：  

```  
>>> L = ('Google', 'Taobao', 'W3CSchool')  
>>> L[2]  
'W3CSchool'  
>>> L[-2]  
'Taobao'  
>>> L[1:]  
('Taobao', 'W3CSchool')  
```  

------  

## 元组内置函数  

Python元组包含了以下内置函数  

| 序号 | 方法及描述                        | 实例                                                         |  
| :--- | :-------------------------------- | :----------------------------------------------------------- |  
| 1    | len(tuple) 计算元组元素个数。     | `>>> tuple1 = ('Google', 'W3CSchool', 'Taobao') >>> len(tuple1) 3 >>>  ` |  
| 2    | max(tuple) 返回元组中元素最大值。 | `>>> tuple2 = ('5', '4', '8') >>> max(tuple2) '8' >>>  `     |  
| 3    | min(tuple) 返回元组中元素最小值。 | `>>> tuple2 = ('5', '4', '8') >>> min(tuple2) '4' >>>  `     |  
| 4    | tuple(seq) 将列表转换为元组。     | `>>> list1= ['Google', 'Taobao', 'W3CSchool', 'Baidu'] >>> tuple1=tuple(list1) >>> tuple1 ('Google', 'Taobao', 'W3CSchool', 'Baidu') ` |  

# 字典  

字典是另一种可变容器模型，且可存储任意类型对象。  

字典的每个键值(key=>value)对用冒号(**:**)分割，每个对之间用逗号(**,**)分割，整个字典包括在花括号(**{})**中 ,格式如下所示：  

```  
d = {key1 : value1, key2 : value2 }  
```  

键必须是唯一的，但值则不必。  

值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。  

一个简单的字典实例：  

```  
dict = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}  
```  

也可如此创建字典：  

```  
dict1 = { 'abc': 456 };  
dict2 = { 'abc': 123, 98.6: 37 };  
```  

------  

## 访问字典里的值  

把相应的键放入熟悉的方括弧，如下实例:  

```  
#!/usr/bin/python3  

dict = {'Name': 'W3CSchool', 'Age': 7, 'Class': 'First'}  

print ("dict['Name']: ", dict['Name'])  
print ("dict['Age']: ", dict['Age'])  
```  

以上实例输出结果：  

```  
dict['Name']:  W3CSchool  
dict['Age']:  7  
```  

如果用字典里没有的键访问数据，会输出错误如下：  

```  
#!/usr/bin/python3  
 
dict = {'Name': 'W3CSchool', 'Age': 7, 'Class': 'First'};  
 
print ("dict['Alice']: ", dict['Alice'])  
```  

以上实例输出结果：  

```  
Traceback (most recent call last):  
  File "test.py", line 5, in <module>  
    print ("dict['Alice']: ", dict['Alice'])  
KeyError: 'Alice'  
```  



------  

## 修改字典  

向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:  

```  
#!/usr/bin/python3  

dict = {'Name': 'W3CSchool', 'Age': 7, 'Class': 'First'}  

dict['Age'] = 8;               # 更新 Age  
dict['School'] = "W3Cschool教程"  # 添加信息  


print ("dict['Age']: ", dict['Age'])  
print ("dict['School']: ", dict['School'])  
```  

以上实例输出结果：  

```  
dict['Age']:  8  
dict['School']:  W3Cschool教程  
```  



------  

## 删除字典元素  

能删单一的元素也能清空字典，清空只需一项操作。  

显示删除一个字典用del命令，如下实例：  

```  
#!/usr/bin/python3  

dict = {'Name': 'W3CSchool', 'Age': 7, 'Class': 'First'}  

del dict['Name'] # 删除键 'Name'  
dict.clear()     # 删除字典  
del dict         # 删除字典  

print ("dict['Age']: ", dict['Age'])  
print ("dict['School']: ", dict['School'])  
```  

但这会引发一个异常，因为用执行 del 操作后字典不再存在：  

```  
Traceback (most recent call last):  
  File "test.py", line 9, in <module>  
    print ("dict['Age']: ", dict['Age'])  
TypeError: 'type' object is not subscriptable  
```  

**注：**del() 方法后面也会讨论。  



## 字典键的特性  

字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。  

两个重要的点需要记住：  

1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：  

```  
#!/usr/bin/python3  

dict = {'Name': 'W3CSchool', 'Age': 7, 'Name': '小菜鸟'}  

print ("dict['Name']: ", dict['Name'])  
```  

以上实例输出结果：  

```  
dict['Name']:  小菜鸟  
```  

2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：  

```  
#!/usr/bin/python3  

dict = {['Name']: 'W3CSchool', 'Age': 7}  

print ("dict['Name']: ", dict['Name'])  
```  

以上实例输出结果：  

```  
Traceback (most recent call last):  
  File "test.py", line 3, in <module>  
    dict = {['Name']: 'W3CSchool', 'Age': 7}  
TypeError: unhashable type: 'list'  
```  



------  

## 字典内置函数&方法  

Python字典包含了以下内置函数：  

| 序号 | 函数及描述                                                   | 实例                                                         |  
| :--- | :----------------------------------------------------------- | :----------------------------------------------------------- |  
| 1    | len(dict) 计算字典元素个数，即键的总数。                     | `>>> dict = {'Name': 'W3CSchool', 'Age': 7, 'Class': 'First'} >>> len(dict) 3 ` |  
| 2    | str(dict) 输出字典以可打印的字符串表示。                     | `>>> dict = {'Name': 'W3CSchool', 'Age': 7, 'Class': 'First'} >>> str(dict) "{'Name': 'W3CSchool', 'Class': 'First', 'Age': 7}" ` |  
| 3    | type(variable) 返回输入的变量类型，如果变量是字典就返回字典类型。 | `>>> dict = {'Name': 'W3CSchool', 'Age': 7, 'Class': 'First'} >>> type(dict) ` |  

Python字典包含了以下内置方法：  

| 序号 | 函数及描述                                                   |  
| :--- | :----------------------------------------------------------- |  
| 1    | [radiansdict.clear()](https://www.w3cschool.cn/python3/python3-att-dictionary-clear.html) 删除字典内所有元素 |  
| 2    | [radiansdict.copy()](https://www.w3cschool.cn/python3/python3-att-dictionary-copy.html) 返回一个字典的浅复制 |  
| 3    | [radiansdict.fromkeys()](https://www.w3cschool.cn/python3/python3-att-dictionary-fromkeys.html) 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |  
| 4    | [radiansdict.get(key, default=None)](https://www.w3cschool.cn/python3/python3-att-dictionary-get.html) 返回指定键的值，如果值不在字典中返回default值 |  
| 5    | [key in dict](https://www.w3cschool.cn/python3/python3-att-dictionary-in-html.html) 如果键在字典dict里返回true，否则返回false |  
| 6    | [radiansdict.items()](https://www.w3cschool.cn/python3/python3-att-dictionary-items.html) 以列表返回可遍历的(键, 值) 元组数组 |  
| 7    | [radiansdict.keys()](https://www.w3cschool.cn/python3/python3-att-dictionary-keys.html) 以列表返回一个字典所有的键 |  
| 8    | [radiansdict.setdefault(key, default=None)](https://www.w3cschool.cn/python3/python3-att-dictionary-setdefault.html) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |  
| 9    | [radiansdict.update(dict2)](https://www.w3cschool.cn/python3/python3-att-dictionary-update.html) 把字典dict2的键/值对更新到dict里 |  
| 10   | [radiansdict.values()](https://www.w3cschool.cn/python3/python3-att-dictionary-values.html) 以列表返回字典中的所有值 |  

# 条件控制  

------  

if **语句**  

Python中if语句的一般形式如下所示：  

```  
if condition_1:  
    statement_block_1  
elif condition_2:  
    statement_block_2  
else:  
    statement_block_3  
```  

如果 "condition_1" 为 True 将执行 "statement_block_1" 块语句，如果 "condition_1" 为False，将判断 "condition_2"，如果"condition_2" 为 True 将执行 "statement_block_2" 块语句，如果 "condition_2" 为False，将执行"statement_block_3"块语句。  

Python中用elif代替了else if，所以if语句的关键字为：if – elif – else。  

**注意：**  

- 1、每个条件后面要使用冒号（:），表示接下来是满足条件后要执行的语句块。  
- 2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。  
- 3、在Python中没有switch – case语句。  

**实例**  

以下实例演示了狗的年龄计算判断：  

```  
age = int(input("Age of the dog: "))  
print()  
if age < 0:  print("This can hardly be true!") elif age == 1:  print("about 14 human years") elif age == 2:  print("about 22 human years") elif age > 2:  
  human = 22 + (age -2)*5  
   print("Human years: ", human)  

###  
input('press Return>')  
```  

将以上脚本保存在dog.py文件中，并执行该脚本：  

```  
python dog.py  
Age of the dog: 1  

about 14 human years  
```  

以下为if中常用的操作运算符:  

| 操作符 | 描述                   |  
| :----- | :--------------------- |  
| `<`    | 小于                   |  
| `<=`   | 小于或等于             |  
| `>`    | 大于                   |  
| `>=`   | 大于或等于             |  
| `==`   | 等于，比较对象是否相等 |  
| `!=`   | 不等于                 |  

**实例**  

```  
# 程序演示了 == 操作符  
# 使用数字  
print(5 == 6)  
# 使用变量  
x = 5  
y = 8  
print(x == y)  
```  

以上实例输出结果：  

```  
False  
False  
```  

high_low.py文件：  

```python  
#!/usr/bin/python3  
# 该实例演示了数字猜谜游戏  
number = 7  
guess = -1  
print("Guess the number!")  
while guess != number:  
    guess = int(input("Is it... "))  
 
    if guess == number:  
        print("Hooray! You guessed it right!")  
    elif guess < number:  
        print("It's bigger...")     
    elif guess > number:  
        print("It's not so big.")  
```  

# 循环  

本章节将为大家介绍Python循环语句的使用。  

Python中的循环语句有 for 和 while。  

Python循环语句的控制结构图如下所示：  

![img](https://atts.w3cschool.cn/attachments/uploads/2014/05/while_loop_1.png)  

------  

## while 循环  

Python中while语句的一般形式：  

```  
while 判断条件：  
    statements  
```  

同样需要注意冒号和缩进。另外，在Python中没有do..while循环。  

以下实例使用了 while 来计算 1 到 100 的总和：  

```  
#!/usr/bin/env python3  

n = 100  

sum = 0  
counter = 1  
while counter <= n:  
	sum = sum + counter     
	counter += 1  
print("Sum of 1 until %d: %d" % (n,sum))  
```  

执行结果如下：  

```  
Sum of 1 until 100: 5050  
```  

------  

## for语句  

Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。  

for循环的一般格式如下：  

```  
for <variable> in <sequence>:  
  <statements>  
else:  
 <statements>  
```  

Python loop循环实例：  

```  
>>> languages = ["C", "C++", "Perl", "Python"]  
>>> for x in languages:  
...     print (x)  
...  
C  
C++  
Perl  
Python  
>>>  
```  

以下实例for实例中使用了 break语句，break语句用于跳出当前循环体：  

```  
#!/usr/bin/env python3  
edibles = ["ham", "spam","eggs","nuts"]  
for food in edibles:  
    if food == "spam":  
        print("No more spam please!")  
        break  
    print("Great, delicious " + food)  
else:  
    print("I am so glad: No spam!")  
print("Finally, I finished stuffing myself")  
```  

执行脚本后，在循环到 "spam"时会跳出循环体：  

```  
Great, delicious ham  
No more spam please!  
Finally, I finished stuffing myself  
```  

------  

## range()函数  

如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:  

```  
>>> for i in range(5):  
...     print(i)  
...  
0  
1  
2  
3  
4  
```  

你也可以使用range指定区间的值：  

```  
>>> for i in range(5,9) :  
  print(i)  

    
5  
6  
7  
8  
>>>  
```  

也可以使range以指定数字开始并指定不同的增量(甚至可以是负数;有时这也叫做'步长'):  

```  
>>> for i in range(0, 10, 3) :  
    print(i)  

    
0  
3  
6  
9  
>>>  
```  

负数：  

```  
>>> for i in range(-10, -100, -30) :  
   print(i)  

    
-10  
-40  
-70  
>>>  
```  

您可以结合range()和len()函数以遍历一个序列的索引,如下所示:  

```  
>>> a = ['Mary', 'had', 'a', 'little', 'lamb']  
>>> for i in range(len(a)):  
...     print(i, a[i])  
...  
0 Mary  
1 had  
2 a  
3 little  
4 lamb  
```  

还可以使用range()函数来创建一个列表：  

```  
>>> list(range(5))  
[0, 1, 2, 3, 4]  
>>>  
```  

------  

## break和continue语句及循环中的else子句  

break语句可以跳出for和while的循环体。如果你从for或while循环中终止，任何对应的循环else块将不执行。  

continue语句被用来告诉Python跳过当前循环块中的剩余语句，然后继续进行下一轮循环。  

循环语句可以有else子句;它在穷尽列表(以for循环)或条件变为假(以while循环)循环终止时被执行,但循环被break终止时不执行.如下查寻质数的循环例子:  

```  
>>> for n in range(2, 10):  
...     for x in range(2, n):  
...         if n % x == 0:  
...             print(n, 'equals', x, '*', n//x)  
...             break  
...     else:  
...         # 循环中没有找到元素  
...         print(n, 'is a prime number')  
...  
2 is a prime number  
3 is a prime number  
4 equals 2 * 2  
5 is a prime number  
6 equals 2 * 3  
7 is a prime number  
8 equals 2 * 4  
9 equals 3 * 3  
```  

------  

## pass语句  

pass语句什么都不做。它只在语法上需要一条语句但程序不需要任何操作时使用.例如:  

```  
>>> while True:  
...     pass  # 等待键盘中断 (Ctrl+C)  
```  

最小的类:  

```  
>>> class MyEmptyClass:  
...     pass  
```  

# 迭代器与生成器  

[一文搞懂Python迭代器和生成器](https://zhuanlan.zhihu.com/p/76831058)  

## 迭代器  

迭代是Python最强大的功能之一，是访问集合元素的一种方式。。  

迭代器是一个可以记住遍历的位置的对象。  

迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。  

迭代器有两个基本的方法：**iter()** 和 **next()**。  

字符串，列表或元组对象都可用于创建迭代器：  

```  
>>> list=[1,2,3,4]  
>>> it = iter(list)    # 创建迭代器对象  
>>> print (next(it))   # 输出迭代器的下一个元素  
1  
>>> print (next(it))  
2  
>>>  
```  

迭代器对象可以使用常规for语句进行遍历：  

```  
#!/usr/bin/python3  

list=[1,2,3,4]  
it = iter(list)    # 创建迭代器对象  
for x in it:  
    print (x, end=" ")  
```  

执行以上程序，输出结果如下：  

```  
1 2 3 4  
```  

也可以使用 next() 函数：  

```  
#!/usr/bin/python3  

import sys         # 引入 sys 模块  

list=[1,2,3,4]  
it = iter(list)    # 创建迭代器对象  

while True:  
    try:  
        print (next(it))  
    except StopIteration:  
        sys.exit()  
```  

执行以上程序，输出结果如下：  

```  
1  
2  
3  
4  
```  

------  

## 生成器  



特点：  

通过列表生成式，我们可以直接创建一个列表。  
但是，受到内存限制，列表容量肯定是有限的。  
而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。  
所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？  
这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。  

在 Python 中，使用了 yield 的函数被称为生成器（generator）。  

跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。  

在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回yield的值。并在下一次执行 next()方法时从当前位置继续运行。  

以下实例使用 yield 实现斐波那契数列：  

```  
#!/usr/bin/python3  

import sys  

def fibonacci(n): # 生成器函数 - 斐波那契  
    a, b, counter = 0, 1, 0  
    while True:  
        if (counter > n):  
            return  
        yield a  
        a, b = b, a + b  
        counter += 1  
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成  

while True:  
    try:  
        print (next(f), end=" ")  
    except StopIteration:  
        sys.exit()  
```  

执行以上程序，输出结果如下：  

```  
0 1 1 2 3 5 8 13 21 34 55  
```  

# 函数  

函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。  

函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。  

------  

## 定义一个函数  

你可以定义一个由自己想要功能的函数，以下是简单的规则：  

- 函数代码块以def关键词开头，后接函数标识符名称和圆括号()。  
- 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。  
- 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。  
- 函数内容以冒号起始，并且缩进。  
- Return[expression]结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。  

------  

**语法**  

def functionname( parameters ):  
   "函数_文档字符串"  
   function_suite  
   return [expression]  

默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。  

**实例**  

以下为一个简单的Python函数，它将一个字符串作为传入参数，再打印到标准显示设备上。  

```  
def printme( str ):  
   "打印传入的字符串到标准显示设备上"  
   print str  
   return  
```  

------  

## 函数调用  

定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。  

这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。  

如下实例调用了printme（）函数：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
# Function definition is here  
def printme( str ):  
   "打印任何传入的字符串"  
   print str;  
   return;  
 
# Now you can call printme function  
printme("我要调用用户自定义函数!");  
printme("再次调用同一函数");  
```  

以上实例输出结果：  

```  
我要调用用户自定义函数!  
再次调用同一函数  
```  

------  

## 参数传递  

在python中，类型属于对象，变量是没有类型的：  

```  
a=[1,2,3]  
 
a="w3cschool"  
```  

以上代码中，[1,2,3] 是 List 类型，"w3cschool"是String类型，而变量a是没有类型，她仅仅是一个对象的引用（一个指针），可以是List类型对象，也可以指向 String类型对象。  

**可更改(mutable)与不可更改(immutable)对象**  

在python中，strings, tuples, 和numbers是不可更改的对象，而 list,dict 等则是可以修改的对象。  

- **不可变类型：**变量赋值a=5后再赋值a=10，这里实际是新生成一个int值对象10，再让a指向它，而5被丢弃，不是改变a的值，相当于新生成了a。  
- **可变类型：**变量赋值la=[1,2,3,4] 后再赋值la[2]=5则是将list la的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。  

python 函数的参数传递：  

- **不可变类型：**类似c++的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。  
- **可变类型：**类似c++的引用传递，如 列表，字典。如fun（la），则是将la真正的传过去，修改后fun外部的la也会受影响  

python中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。  

**python 传不可变对象实例**  

实例（Python 2.0+）  

```  
#!/usr/bin/python  
# -*- coding: UTF-8 -*-  
 
def ChangeInt( a ):  
    a = 10  
 
b = 2  
ChangeInt(b)  
print b # 结果是 2  
```  

实例中有int对象2，指向它的变量是b，在传递给ChangeInt函数时，按传值的方式复制了变量b，a和b都指向了同一个 Int 对象，在a=10时，则新生成一个int值对象 10，并让a指向它。  

按值传递参数和按引用传递参数（传可变对象实例）****  

所有参数（自变量）在Python里都是按引用传递。如果你在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
# 可写函数说明  
def changeme( mylist ):  
   "修改传入的列表"  
   mylist.append([1,2,3,4]);  
   print "函数内取值: ", mylist  
   return  
 
# 调用changeme函数  
mylist = [10,20,30];  
changeme( mylist );  
print "函数外取值: ", mylist  
```  

传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：  

```  
函数内取值:  [10, 20, 30, [1, 2, 3, 4]]  
函数外取值:  [10, 20, 30, [1, 2, 3, 4]]  
```  

------  

## 参数  

以下是调用函数时可使用的正式参数类型：  

- 必备参数  
- 命名参数  
- 缺省参数  
- 不定长参数  

**必备参数**  

必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。  

调用printme()函数，你必须传入一个参数，不然会出现语法错误：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
#可写函数说明  
def printme( str ):  
   "打印任何传入的字符串"  
   print str;  
   return;  
 
#调用printme函数  
printme();  
```  

以上实例输出结果：  

```  
Traceback (most recent call last):  
  File "test.py", line 11, in <module>  
    printme();  
TypeError: printme() takes exactly 1 argument (0 given)  
```  



关键字参数  

关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。  

使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。  

以下实例在函数 printme() 调用时使用参数名：  

```  
#!/usr/bin/python  
# -*- coding: UTF-8 -*-  
 
#可写函数说明  
def printme( str ):  
   "打印任何传入的字符串"  
   print str;  
   return;  
 
#调用printme函数  
printme( str = "My string");  
```  

以上实例输出结果：  

```  
My string  
```  

下例能将关键字参数顺序不重要展示得更清楚：  

```  
#!/usr/bin/python  
# -*- coding: UTF-8 -*-  
 
#可写函数说明  
def printinfo( name, age ):  
   "打印任何传入的字符串"  
   print "Name: ", name;  
   print "Age ", age;  
   return;  
 
#调用printinfo函数  
printinfo( age=50, name="miki" );  
```  

以上实例输出结果：  

```  
Name:  miki  
Age  50  
```  

命名参数  

命名参数和函数调用关系紧密，调用方用参数的命名确定传入的参数值。你可以跳过不传的参数或者乱序传参，因为Python解释器能够用参数名匹配参数值。用命名参数调用printme()函数：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
#可写函数说明  
def printme( str ):  
   "打印任何传入的字符串"  
   print str;  
   return;  
 
#调用printme函数  
printme( str = "My string");  
```  

以上实例输出结果：  

```  
My string  
```  

下例能将命名参数顺序不重要展示得更清楚：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
#可写函数说明  
def printinfo( name, age ):  
   "打印任何传入的字符串"  
   print "Name: ", name;  
   print "Age ", age;  
   return;  
 
#调用printinfo函数  
printinfo( age=50, name="miki" );  
```  

以上实例输出结果：  

```  
Name:  miki  
Age  50  
```  

**缺省参数**  

调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
#可写函数说明  
def printinfo( name, age = 35 ):  
   "打印任何传入的字符串"  
   print "Name: ", name;  
   print "Age ", age;  
   return;  
 
#调用printinfo函数  
printinfo( age=50, name="miki" );  
printinfo( name="miki" );  
```  

以上实例输出结果：  

```  
Name:  miki  
Age  50  
Name:  miki  
Age  35  
```  

**不定长参数**  

你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下：  

```  
def functionname([formal_args,] *var_args_tuple ):  
   "函数_文档字符串"  
   function_suite  
   return [expression]  
```  

加了星号（*）的变量名会存放所有未命名的变量参数。选择不多传参数也可。如下实例：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
# 可写函数说明  
def printinfo( arg1, *vartuple ):  
   "打印任何传入的参数"  
   print "输出: "  
   print arg1  
   for var in vartuple:  
      print var  
   return;  
 
# 调用printinfo 函数  
printinfo( 10 );  
printinfo( 70, 60, 50 );  
```  

以上实例输出结果：  

```  
输出:  
10  
输出:  
70  
60  
50  
```  

------  

## 匿名函数  

python 使用 lambda 来创建匿名函数。  

- lambda只是一个表达式，函数体比def简单很多。  
- lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。  
- lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。  
- 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。  

**语法**  

lambda函数的语法只包含一个语句，如下：  

```  
lambda [arg1 [,arg2,.....argn]]:expression  
```  

如下实例：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
#可写函数说明  
sum = lambda arg1, arg2: arg1 + arg2;  
 
#调用sum函数  
print "Value of total : ", sum( 10, 20 )  
print "Value of total : ", sum( 20, 20 )  
```  

以上实例输出结果：  

```  
Value of total :  30  
Value of total :  40  
```  

------  

## return语句  

return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
# 可写函数说明  
def sum( arg1, arg2 ):  
   # 返回2个参数的和."  
   total = arg1 + arg2  
   print "Inside the function : ", total  
   return total;  
 
# 调用sum函数  
total = sum( 10, 20 );  
print "Outside the function : ", total  
```  

以上实例输出结果：  

```  
Inside the function :  30  
Outside the function :  30  
```  

------  

## 变量作用域  

一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。  

变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下：  

- 全局变量  
- 局部变量  

------  

## 变量和局部变量  

定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。  

局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：  

```  
#coding=utf-8  
#!/usr/bin/python  
 
total = 0; # This is global variable.  
# 可写函数说明  
def sum( arg1, arg2 ):  
   #返回2个参数的和."  
   total = arg1 + arg2; # total在这里是局部变量.  
   print "Inside the function local total : ", total  
   return total;  
 
#调用sum函数  
sum( 10, 20 );  
print "Outside the function global total : ", total  
```  

以上实例输出结果：  

```  
Inside the function local total :  30  
Outside the function global total :  0  
```  

# 正则  

## **compile()**  

编译正则表达式模式，返回一个对象的模式。（可以把那些常用的正则表达式编译成正则表达式对象，这样可以提高一点效率。）  

格式：  

re.compile(pattern,flags=0)  

pattern: 编译时用的表达式字符串。  

flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等。常用的flags有：  

| 标志               | 含义                                                         |  
| ------------------ | ------------------------------------------------------------ |  
| re.S(DOTALL)       | 使.匹配包括换行在内的所有字符                                |  
| re.I（IGNORECASE） | 使匹配对大小写不敏感                                         |  
| re.L（LOCALE）     | 做本地化识别（locale-aware)匹配，法语等![img](file:///C:/Users/tina/AppData/Local/YNote/data/heoffer@126.com/15ef610b4afd4cf0aea99402f970595e/19c23298f53f40f1b1d0168871156605.jpg) |  
| re.M(MULTILINE)    | 多行匹配，影响^和$                                           |  
| re.X(VERBOSE)      | 该标志通过给予更灵活的格式以便将正则表达式写得更易于理解     |  
| re.U               | 根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B           |  

 

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)  

```  
import re  
tt = "Tina is a good girl, she is cool, clever, and so on..."  
rr = re.compile(r'\w*oo\w*')  
print(rr.findall(tt))   #查找所有包含'oo'的单词  
执行结果如下：  
['good', 'cool']  
```  

## re.match函数  

re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。  

**函数语法**：  

```  
re.match(pattern, string, flags=0)  
```  

函数参数说明：  

| 参数    | 描述                                                         |  
| :------ | :----------------------------------------------------------- |  
| pattern | 匹配的正则表达式                                             |  
| string  | 要匹配的字符串。                                             |  
| flags   | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 |  

匹配成功re.match方法返回一个匹配的对象，否则返回None。  

我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。  

| 匹配对象方法 | 描述                                                         |  
| :----------- | :----------------------------------------------------------- |  
| group(num=0) | 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 |  
| groups()     | 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。     |  

例1:  

```python  
>>> import re  
>>> print(re.match('www','www.baidu.com').span())  
(0, 3)  
##不在起始位置  
>>> print(re.match('com','www.baidu.com'))  
None  
##匹配不成功也是None  
>>> print(re.match('llll','www.baidu.com'))  
None  

```  

例2：  

```python  
#!/usr/bin/python3  
import re  

line = "Cats are smarter than dogs"  

matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)  

if matchObj:  
   print ("matchObj.group() : ", matchObj.group())  
   print ("matchObj.group(1) : ", matchObj.group(1))  
   print ("matchObj.group(2) : ", matchObj.group(2))  
else:  
   print ("No match!!")  

```  

以上实例执行结果如下：  

```python  
matchObj.group() :  Cats are smarter than dogs  
matchObj.group(1) :  Cats  
matchObj.group(2) :  smarter  
```  

## re.search方法  

re.search 扫描整个字符串并返回第一个成功的匹配。  

语法同re.match  

```python  
(0, 3)  
>>> print(re.search('com','www.baidu.com').span())  
(10, 13)  
```  

## re.match与re.search与re.findall的区别  

re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。  

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)  

```  
a=re.search('[\d]',"abc33").group()  
print(a)  
p=re.match('[\d]',"abc33")  
print(p)  
b=re.findall('[\d]',"abc33")  
print(b)  
执行结果：  
3  
None  
['3', '3']  
```  

## findall()  

re.findall遍历匹配，可以获取字符串中所有匹配的字符串，返回一个列表。  

 格式：  

re.findall(pattern, string, flags=0)  

```python  
p = re.compile(r'\d+')  
print(p.findall('o1n2m3k4'))  
执行结果如下：  
['1', '2', '3', '4']  
```  

## **split()**  

按照能够匹配的子串将string分割后返回列表。  

可以使用re.split来分割字符串，如：re.split(r'\s+', text)；将字符串按空格分割成一个单词列表。  

格式：  

re.split(pattern, string[, maxsplit])  

maxsplit用于指定最大分割次数，不指定将全部分割。  

```  
print(re.split('\d+','one1two2three3four4five5'))  
执行结果如下：  
['one', 'two', 'three', 'four', 'five', '']  
```  



## 检索和替换  

Python 的re模块提供了re.sub用于替换字符串中的匹配项。  



语法：  

```  
re.sub(pattern, repl, string, max=0)  
```  

返回的字符串是在字符串中用 RE 最左边不重复的匹配来替换。如果模式没有发现，字符将被没有改变地返回。  

可选参数 count 是模式匹配后替换的最大次数；count 必须是非负整数。缺省值是 0 表示替换所有的匹配。  

实例：  

```  
#!/usr/bin/python3  

import re  

phone = "2004-959-559 # 这是一个电话号码"  

# 删除注释  
num = re.sub(r'#.*$', "", phone)  
print ("电话号码 : ", num)  

# 移除非数字的内容  
num = re.sub(r'\D', "", phone)  
print ("电话号码 : ", num)  
```  

以上实例执行结果如下：  

```python  
电话号码 :  2004-959-559  
电话号码 :  2004959559  
```  

**subn()**  

 返回替换次数  

格式：  

subn(pattern, repl, string, count=0, flags=0)  

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)  

```python  
print(re.subn('[1-2]','A','123456abcdef'))  
print(re.sub("g.t","have",'I get A,  I got B ,I gut C'))  
print(re.subn("g.t","have",'I get A,  I got B ,I gut C'))  
执行结果如下：  
('AA3456abcdef', 2)  
I have A,  I have B ,I have C  
('I have A,  I have B ,I have C', 3)  
```  

## 正则表达式修饰符 - 可选标志  

正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志：  

| 修饰符 | 描述                                                         |  
| :----- | :----------------------------------------------------------- |  
| re.I   | 使匹配对大小写不敏感                                         |  
| re.L   | 做本地化识别（locale-aware）匹配                             |  
| re.M   | 多行匹配，影响 ^ 和 $                                        |  
| re.S   | 使 . 匹配包括换行在内的所有字符                              |  
| re.U   | 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.      |  
| re.X   | 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 |  

## 正则表达式模式  

模式字符串使用特殊的语法来表示一个正则表达式：  

字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。  

多数字母和数字前加一个反斜杠时会拥有不同的含义。  

标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。  

反斜杠本身需要使用反斜杠转义。  

由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'/t'，等价于'//t')匹配相应的特殊字符。  

下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。  

| 模式        | 描述                                                         |  
| :---------- | :----------------------------------------------------------- |  
| ^           | 匹配字符串的开头                                             |  
| $           | 匹配字符串的末尾。                                           |  
| .           | 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 |  
| [...]       | 用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'          |  
| [^...]      | 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。             |  
| re*         | 匹配0个或多个的表达式。                                      |  
| re+         | 匹配1个或多个的表达式。                                      |  
| re?         | 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式         |  
| re{ n}      | 匹配n个前面表达式。例如，"o{2}"不能匹配"Bob"中的"o"，但是能匹配"food"中的两个o。 |  
| re{ n,}     | 精确匹配n个前面表达式。例如，"o{2,}"不能匹配"Bob"中的"o"，但能匹配"foooood"中的所有o。"o{1,}"等价于"o+"。"o{0,}"则等价于"o*"。 |  
| re{ n, m}   | 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式         |  
| a\| b       | 匹配a或b                                                     |  
| (re)        | G匹配括号内的表达式，也表示一个组                            |  
| (?imx)      | 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 |  
| (?-imx)     | 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。     |  
| (?: re)     | 类似 (...), 但是不表示一个组                                 |  
| (?imx: re)  | 在括号中使用i, m, 或 x 可选标志                              |  
| (?-imx: re) | 在括号中不使用i, m, 或 x 可选标志                            |  
| (?#...)     | 注释.                                                        |  
| (?= re)     | 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 |  
| (?! re)     | 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 |  
| (?> re)     | 匹配的独立模式，省去回溯。                                   |  
| \w          | 匹配字母数字                                                 |  
| \W          | 匹配非字母数字                                               |  
| \s          | 匹配任意空白字符，等价于 [\t\n\r\f].                         |  
| \S          | 匹配任意非空字符                                             |  
| \d          | 匹配任意数字，等价于 [0-9].                                  |  
| \D          | 匹配任意非数字                                               |  
| \A          | 匹配字符串开始                                               |  
| \Z          | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。c |  
| \z          | 匹配字符串结束                                               |  
| \G          | 匹配最后匹配完成的位置。                                     |  
| \b          | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |  
| \B          | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |  
| \n, \t, 等. | 匹配一个换行符。匹配一个制表符。等                           |  
| \1...\9     | 匹配第n个分组的子表达式。                                    |  
| \10         | 匹配第n个分组的子表达式，如果它经匹配。否则指的是八进制字符码的表达式。 |  

## 正则表达式实例  

**字符匹配**  

| 实例   | 描述           |  
| :----- | :------------- |  
| python | 匹配 "python". |  

**字符类**  

| 实例        | 描述                              |  
| :---------- | :-------------------------------- |  
| [Pp]ython   | 匹配 "Python" 或 "python"         |  
| rub[ye]     | 匹配 "ruby" 或 "rube"             |  
| [aeiou]     | 匹配中括号内的任意一个字母        |  
| [0-9]       | 匹配任何数字。类似于 [0123456789] |  
| [a-z]       | 匹配任何小写字母                  |  
| [A-Z]       | 匹配任何大写字母                  |  
| [a-zA-Z0-9] | 匹配任何字母及数字                |  
| [^aeiou]    | 除了aeiou字母以外的所有字符       |  
| [^0-9]      | 匹配除了数字外的字符              |  

**特殊字符类**  

| 实例 | 描述                                                         |  
| :--- | :----------------------------------------------------------- |  
| .    | 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。 |  
| \d   | 匹配一个数字字符。等价于 [0-9]。                             |  
| \D   | 匹配一个非数字字符。等价于 [^0-9]。                          |  
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |  
| \S   | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |  
| \w   | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。         |  
| \W   | 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。                 |  

## 贪婪匹配与非贪婪匹配  

*?,+?,??,{m,n}?   前面的*,+,?等都是贪婪匹配，也就是尽可能匹配，后面加?号使其变成惰性匹配  

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)  

```  
a = re.findall(r"a(\d+?)",'a23b')  
print(a)  
b = re.findall(r"a(\d+)",'a23b')  
print(b)  
执行结果：  
['2']  
['23']  
```  

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)  

```  
a = re.match('<(.*)>','<H1>title<H1>').group()  
print(a)  
b = re.match('<(.*?)>','<H1>title<H1>').group()  
print(b)  
执行结果：  
<H1>title<H1>  
<H1>  
```  

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)  

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)  

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)  

```  
a = re.findall(r"a(\d+)b",'a3333b')  
print(a)  
b = re.findall(r"a(\d+?)b",'a3333b')  
print(b)  
执行结果如下：  
['3333']  
['3333']  
#######################  
这里需要注意的是如果前后均有限定条件的时候，就不存在什么贪婪模式了，非匹配模式失效。  
```  

## 用flags时遇到的小坑  

```  
print(re.split('a','1A1a2A3',re.I))#输出结果并未能区分大小写  
这是因为re.split(pattern，string，maxsplit,flags)默认是四个参数，当我们传入的三个参数的时候，系统会默认re.I是第三个参数，所以就没起作用。如果想让这里的re.I起作用，写成flags=re.I即可。  
```  